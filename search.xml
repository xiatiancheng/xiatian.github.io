<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记录</title>
      <link href="/xiatian.github.io/2022/01/22/vue/"/>
      <url>/xiatian.github.io/2022/01/22/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="1-vue2-gt-vue3-生命周期"><a href="#1-vue2-gt-vue3-生命周期" class="headerlink" title="1.vue2 -> vue3 生命周期"></a>1.vue2 -&gt; vue3 生命周期</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">beforeCreate <span class="token operator">-</span><span class="token operator">&gt;</span> 使用 <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>created <span class="token operator">-</span><span class="token operator">&gt;</span> 使用 <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>beforeMount <span class="token operator">-</span><span class="token operator">&gt;</span> onBeforeMountmounted <span class="token operator">-</span><span class="token operator">&gt;</span> onMountedbeforeUpdate <span class="token operator">-</span><span class="token operator">&gt;</span> onBeforeUpdateupdated <span class="token operator">-</span><span class="token operator">&gt;</span> onUpdatedbeforeDestroy <span class="token operator">-</span><span class="token operator">&gt;</span> onBeforeUnmountdestroyed <span class="token operator">-</span><span class="token operator">&gt;</span> onUnmounted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-父子组件传值"><a href="#2-父子组件传值" class="headerlink" title="2.父子组件传值"></a>2.父子组件传值</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span>、父子组件通信    <span class="token operator">-</span> props    <span class="token operator">-</span> $emit<span class="token operator">/</span>$on    <span class="token operator">-</span> $children<span class="token operator">/</span>$parent    <span class="token operator">-</span> $attrs<span class="token operator">/</span>$listeners    <span class="token operator">-</span> ref<span class="token number">2</span>、兄弟组件    <span class="token operator">-</span> $parent    <span class="token operator">-</span> $root    <span class="token operator">-</span> eventbus    <span class="token operator">-</span> vuex<span class="token number">3</span>、跨层级关系    <span class="token operator">-</span> eventbus    <span class="token operator">-</span> vuex    <span class="token operator">-</span> provide<span class="token operator">/</span>inject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-data-为什么是一个函数而不是对象"><a href="#3-data-为什么是一个函数而不是对象" class="headerlink" title="3.data 为什么是一个函数而不是对象"></a>3.data 为什么是一个函数而不是对象</h2><ol><li>函数每次执行都会返回全新data对象实例</li><li>在JS当中实例是通过构造函数来创建的，每个构造函数可以new出很多个实例，那么每个实例都会继承原型上的方法或属性。</li><li>因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。</li></ol><h2 id="4-v-if-和-v-for-哪个优先级高"><a href="#4-v-if-和-v-for-哪个优先级高" class="headerlink" title="4.v-if 和 v-for 哪个优先级高"></a>4.v-if 和 v-for 哪个优先级高</h2><ol><li>v-for优先于v-if 被解析</li><li>如果同时出现，每次渲染都会先执行循环在判断条件，无论如何，循环都不可避免，浪费了性能</li><li>要避免出现这种情况，可以在外层嵌套 template，在这一层加v-if，然后内部进行v-for循环</li><li>如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项</li></ol><h2 id="5-你知道-vue-中-key-的作用和工作原理吗？说说你对它的理解"><a href="#5-你知道-vue-中-key-的作用和工作原理吗？说说你对它的理解" class="headerlink" title="5.你知道 vue 中 key 的作用和工作原理吗？说说你对它的理解"></a>5.你知道 vue 中 key 的作用和工作原理吗？说说你对它的理解</h2><ol><li>key 的作用主要就是为了高效的更新DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁的更新相同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。</li><li>如果不设置key，还可能在列表更新时引发一些隐藏bug</li><li>vue中在使用相同标签名元素的过度切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue 只会替换其内部属性而不会触发过度效果。</li></ol><h2 id="6-谈谈你对-MVC、MVP-和-MVVM-的理解"><a href="#6-谈谈你对-MVC、MVP-和-MVVM-的理解" class="headerlink" title="6.谈谈你对 MVC、MVP 和 MVVM 的理解"></a>6.谈谈你对 MVC、MVP 和 MVVM 的理解</h2><ol><li>这三个都是框架模式，它们设计的目标都是解决Model和View的耦合问题</li><li>MVC模式出现比较早，主要应用在后端，在前端领域的早期也有应用，如Backbone.js。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题</li><li>MVP模式是MVC的进化形式，Presenter作为中间层负责MV通信，解决了两者耦合问题，但P层过于臃肿会导致维护问题</li><li>MVVM模式在前端领域有广泛的应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。</li></ol><h2 id="7-你了解哪些-vue-性能优化的方法"><a href="#7-你了解哪些-vue-性能优化的方法" class="headerlink" title="7.你了解哪些 vue 性能优化的方法"></a>7.你了解哪些 vue 性能优化的方法</h2><ol><li>路由懒加载</li><li>keep-alive缓存页面</li><li>v-show复用DOM</li><li>v-for遍历避免同时使用v-if</li><li>长列表性能优化<ul><li>纯数据，非响应式的可以 使用 object.freeze 冻结</li><li>大数据长列表，可采用虚拟滚动，只渲染少部分内容 （vue-virtual-scroller、vue-virtual-scroll-list）</li></ul></li><li>事件的销毁</li><li>图片的懒加载 （vue-lazyload）</li><li>第三方插件按需引入</li><li>无状态组件标记为函数组件 functional</li><li>子组件分割</li><li>变量本地化</li><li>SSR （SEO、首屏渲染）</li></ol><h2 id="7-vue3-新特性"><a href="#7-vue3-新特性" class="headerlink" title="7.vue3 新特性"></a>7.vue3 新特性</h2><ol><li>更快</li></ol><ul><li>虚拟DOM重写（编译时提示减少运行时开销，使用更有效的代码创建虚拟节点。组件快速路径+单个调用+子节点类型检查。跳过不必要的条件分支。js引擎更容易优化）</li><li>优化slots的生成（vue3中可以单独重新渲染父级和子级。确保实例正确的跟踪依赖关系。避免不必要的父子组件重新渲染）</li><li>静态树提升（内存换时间，Vue3 的编译器将能够检测到什么是静态的，然后将其提升，从而降低了渲染成本。跳过修补整棵树，从而降低渲染成本。即使多次出现也能正常工作 ）</li><li>静态属性提升 （Vue3 打补丁时将跳过这些属性不会改变的节点）</li><li>基于Proxy的响应式系统 （组件实例初始化的速度提高100％ 。使用Proxy节省以前一半的内存开销，加快速度，但是存在低浏览器版本的不兼容。为了继续支持IE11，Vue3 将发布一个支持旧观察者机制和新 Proxy 版本的构建）</li></ul><ol start="2"><li>更小</li></ol><ul><li>通过摇树优化核心库体积</li></ul><ol start="3"><li>更容易维护</li></ol><ul><li>TS+模块化 （它不仅会使用 TypeScript，而且许多包被解耦，更加模块化。）</li></ul><ol start="4"><li>更加友好</li></ol><ul><li>跨平台：编译器核心和运行时核心与平台无关</li></ul><ol start="5"><li>更容易使用</li></ol><ul><li>改进ts支持，编译器提供更好的类型检查和错误及警告</li><li>更好的调试支持</li><li>独立的响应式模块</li><li>Composition API</li></ul><h3 id="7-1-Vue-js-3-0-放弃-defineProperty-使用-Proxy-的原因"><a href="#7-1-Vue-js-3-0-放弃-defineProperty-使用-Proxy-的原因" class="headerlink" title="7.1 Vue.js 3.0 放弃 defineProperty, 使用 Proxy 的原因"></a>7.1 Vue.js 3.0 放弃 defineProperty, 使用 Proxy 的原因</h3><p>Object.defineProperty缺陷</p><ol><li>监控到数组下标的变化时，开销很大。所以Vue.js放弃了下标变化的检测；</li><li>Object.defineProperty只能劫持对象的属性，而Proxy是直接代理对象。Object.defineProperty需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</li><li>Object.defineProperty对新增属性需要手动进行Observe。vue2时需要使用 vm.$set 才能保证新增的属性也是响应式</li><li>Proxy支持13种拦截操作，这是defineProperty所不具有的</li><li>Proxy 作为新标准，长远来看，JS引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化</li></ol><h3 id="7-2-Vue-的双向数据绑定原理是什么？"><a href="#7-2-Vue-的双向数据绑定原理是什么？" class="headerlink" title="7.2 Vue 的双向数据绑定原理是什么？"></a>7.2 Vue 的双向数据绑定原理是什么？</h3><ol><li>原理（Vue2.x）</li></ol><ul><li>Vue.js它是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter；</li><li>在数据变动时发布消息给订阅者，触发相应的监听回调。</li><li>vue3中使用了ES6的Proxy(代理)代理和数据data绑定之后，任何操作都会经过代理实现，就没有了监听不到的情况。</li><li>在vue3中，通常使用ref和reactive进行数据绑定,注意其获取数值方式的.value方法而非直接获取。</li></ul><blockquote><p>面试简单来说：defineProterty 是劫持对象的数据,而 proxy 是整个对象</p></blockquote><h3 id="7-3-Vue中如何检测数组的变化？"><a href="#7-3-Vue中如何检测数组的变化？" class="headerlink" title="7.3 Vue中如何检测数组的变化？"></a>7.3 Vue中如何检测数组的变化？</h3><p>vue中对数组没有进行defineProperty，而是重写了数组的7个方法。 分别是：</p><ol><li>push</li><li>shift</li><li>pop</li><li>splice</li><li>unshift</li><li>sort</li><li>reverse<br>因为这些方法都会改变数组本身。数组里的索引和长度是无法被监控的。</li></ol><h2 id="8-你知道-nextTick-吗？它是干什么的？实现原理是什么？"><a href="#8-你知道-nextTick-吗？它是干什么的？实现原理是什么？" class="headerlink" title="8.你知道 nextTick 吗？它是干什么的？实现原理是什么？"></a>8.你知道 nextTick 吗？它是干什么的？实现原理是什么？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">dom更新之后执行的回调<span class="token punctuation">,</span> 可以用来获取更新后的dom元素<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-普通函数-箭头函数的区别-构造函数"><a href="#9-普通函数-箭头函数的区别-构造函数" class="headerlink" title="9. 普通函数 箭头函数的区别- 构造函数"></a>9. 普通函数 箭头函数的区别- 构造函数</h2><ol><li>箭头函数没有原型 原型是undefined</li><li>箭头函数this指向全局对象 而函数指向引用对象</li><li>call，apply，bind方法改变不了箭头函数的指向</li></ol><h2 id="9-基本类型-引用类型"><a href="#9-基本类型-引用类型" class="headerlink" title="9. 基本类型 引用类型"></a>9. 基本类型 引用类型</h2><ol><li>JavaScript 中共有 6 种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol (new in ES 6) ！引用类型 object</li></ol><ul><li>typeof：经常用来检测一个变量是不是最基本的数据类型<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a<span class="token punctuation">;</span><span class="token keyword">typeof</span> a<span class="token punctuation">;</span>    <span class="token comment">// undefined</span>a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> a<span class="token punctuation">;</span>    <span class="token comment">// object</span>a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> a<span class="token punctuation">;</span>    <span class="token comment">// boolean</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="2"><li>instanceof：用来判断某个构造函数的 prototype 属性所指向的对象是否存在于另外一个要检测对象的原型链上<br>简单说就是判断一个引用类型的变量具体是不是某种类型的对象<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span>              <span class="token comment">// true</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>               <span class="token comment">// true</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">aa</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span>           <span class="token comment">// true</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span>  <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="10-vue2-和-vue3-的区别-vue3-快在哪"><a href="#10-vue2-和-vue3-的区别-vue3-快在哪" class="headerlink" title="10. vue2 和 vue3 的区别 (vue3 快在哪)"></a>10. vue2 和 vue3 的区别 (vue3 快在哪)</h2><ol><li>diff算法增加patchFlag静态标识，只对比有静态标识的dom元素</li><li>事件增加缓存</li><li>很多文本节点提升 只定义一次，渲染时不需要再次定义，vue2每次都需要重新定义</li><li>ssr渲染 以字符串方式渲染</li><li>proxy替换了之前的defineProterty</li><li>vite</li><li>ts</li></ol><h2 id="11-vuex-的核心概念"><a href="#11-vuex-的核心概念" class="headerlink" title="11. vuex 的核心概念"></a>11. vuex 的核心概念</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token parameter">state</span> <span class="token operator">=&gt;</span> 基本数据<span class="token parameter">getters</span> <span class="token operator">=&gt;</span> 从基本数据派生的数据<span class="token parameter">mutations</span> <span class="token operator">=&gt;</span> 修改数据，同步<span class="token parameter">actions</span> <span class="token operator">=&gt;</span> <span class="token function">修改数据，异步</span> <span class="token punctuation">(</span>Action 提交的是 mutation，而不是直接变更状态<span class="token punctuation">)</span><span class="token parameter">modules</span> <span class="token operator">=&gt;</span> 模块化Vuex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-1-vuex-中-mutations-与-actions-的使用及区别"><a href="#11-1-vuex-中-mutations-与-actions-的使用及区别" class="headerlink" title="11.1 vuex 中 mutations 与 actions 的使用及区别"></a>11.1 vuex 中 mutations 与 actions 的使用及区别</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1.</span>Action 提交的是 mutation，而不是直接变更状态。<span class="token number">2.</span>Action 可以包含任意异步操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="12-vue-router-有哪几种导航钩子？"><a href="#12-vue-router-有哪几种导航钩子？" class="headerlink" title="12. vue-router 有哪几种导航钩子？"></a>12. vue-router 有哪几种导航钩子？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">全局导航钩子：router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token function">组件内的钩子：beforeRouteEnter</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next<span class="token punctuation">)</span>单独路由独享组件：beforeEnter<span class="token operator">:</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="12-1-路由的两种方式-路由守卫"><a href="#12-1-路由的两种方式-路由守卫" class="headerlink" title="12.1 路由的两种方式 路由守卫"></a>12.1 路由的两种方式 路由守卫</h3><ol><li>hash —— 它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li><li>history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，<br>在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。</li></ol><h2 id="13-v-model-是如何实现的，语法糖实际是什么？"><a href="#13-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="13. v-model 是如何实现的，语法糖实际是什么？"></a>13. v-model 是如何实现的，语法糖实际是什么？</h2><ol><li>作用在表单元素上 v-model=”message” 等同于 v-bind:value=”message” v-on:input=”message=$event.target.value”</li><li>作用在组件上, 本质是一个父子组件通信的语法糖，通过prop和$.emit实现, 等同于:value=”message” @input=” $emit(‘input’, $event.target.value)”</li></ol><h2 id="14-常见的事件修饰符及其作用？"><a href="#14-常见的事件修饰符及其作用？" class="headerlink" title="14.常见的事件修饰符及其作用？"></a>14.常见的事件修饰符及其作用？</h2><ol><li>.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</li><li>.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li>.capture ：当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。如 div1中嵌套div2中嵌套div3.capture中嵌套div4，那么执行顺序为：div3=》div4=》div2=》div1</li><li>.self ：只会触发自己范围内的事件，不包含子元素；</li><li>.once ：只会触发一次。</li></ol><h2 id="15-过滤器-Filter"><a href="#15-过滤器-Filter" class="headerlink" title="15.过滤器 (Filter)"></a>15.过滤器 (Filter)</h2><ol><li>在Vue中使用filters来过滤(格式化)数据，filters不会修改数据，而是过滤(格式化)数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示。</li><li>使用场景： 比如需要处理时间、数字等的的显示格式；</li></ol><h2 id="16-Vue-2-中给-data-中添加一个新的属性？如何解决？"><a href="#16-Vue-2-中给-data-中添加一个新的属性？如何解决？" class="headerlink" title="16.Vue 2 中给 data 中添加一个新的属性？如何解决？"></a>16.Vue 2 中给 data 中添加一个新的属性？如何解决？</h2><p>视图并未刷新。这是因为在Vue实例创建时，新属性并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()： this.$set(this.obj, ‘new_property’, ‘new_value’)</p><h2 id="17-说说你自己项目碰到的难点"><a href="#17-说说你自己项目碰到的难点" class="headerlink" title="17. 说说你自己项目碰到的难点"></a>17. 说说你自己项目碰到的难点</h2><blockquote><p>结合自己项目 说几个 可以往自己擅长方向引 比如性能优化 数据埋点 或者工程化实践等等</p></blockquote><h2 id="18-false-和-false"><a href="#18-false-和-false" class="headerlink" title="18. []==false 和 ![]==false"></a>18. []==false 和 ![]==false</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">第一个 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">false</span> 转为数字 <span class="token number">0</span><span class="token operator">==</span><span class="token number">0</span>第二个 <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">false</span> 转为布尔 <span class="token boolean">false</span><span class="token operator">==</span><span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="19-vue-和-react-的相同点和不同点-两个问题"><a href="#19-vue-和-react-的相同点和不同点-两个问题" class="headerlink" title="19. vue 和 react 的相同点和不同点 两个问题"></a>19. vue 和 react 的相同点和不同点 两个问题</h2><ol><li>相同：<ul><li>都使用了虚拟dom、</li><li>都有ssr、</li><li>都支持jsx，</li><li>性能好、</li><li>响应式、</li><li>数据驱动、</li><li>将注意力集中保持在核心库，同时也关注路由和负责处理全局状态管理的辅助库。</li></ul></li><li>区别：<ul><li>vue使用于小项目、</li><li>vue学习成本低、</li><li>vue渲染更快、</li><li>vue有模板而react是jsx、</li><li>vue双向数据绑定，</li><li>react是单向、</li><li>vue有指令语法、</li></ul></li></ol><h2 id="20-http-请求的方法有哪些"><a href="#20-http-请求的方法有哪些" class="headerlink" title="20.http 请求的方法有哪些"></a>20.http 请求的方法有哪些</h2><ol><li> get</li><li> post</li><li> head</li><li> put</li><li> delete</li><li> connect</li><li> trace</li><li> options</li></ol><h2 id="21-js闭包的概念"><a href="#21-js闭包的概念" class="headerlink" title="21. js闭包的概念"></a>21. js闭包的概念</h2><blockquote><p>一个函数和该函数所拥有的变量之和的环境，外部获取使用该变量 但是不能被外部直接改变 要使用该函数拥有的方法去调用</p></blockquote><h2 id="22-cookies，sessionStorage-和-localStorage-的区别？"><a href="#22-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="22. cookies，sessionStorage 和 localStorage 的区别？"></a>22. cookies，sessionStorage 和 localStorage 的区别？</h2><ol><li>cookie:</li></ol><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li></ul><ol start="2"><li>存储大小：</li></ol><ul><li>cookie数据大小不能超过4k。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li></ul><ol start="3"><li>过期时间：</li></ol><ul><li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li><li>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</li><li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul><p><img src="https://s4.ax1x.com/2022/01/22/7fwPHK.gif" alt="要加油啊"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端,vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react</title>
      <link href="/xiatian.github.io/2021/10/07/react/"/>
      <url>/xiatian.github.io/2021/10/07/react/</url>
      
        <content type="html"><![CDATA[<h2 id="1-涉及到场景主要是-react-用到-echarts-数据更新"><a href="#1-涉及到场景主要是-react-用到-echarts-数据更新" class="headerlink" title="1.涉及到场景主要是 react 用到 echarts 数据更新"></a>1.涉及到场景主要是 react 用到 echarts 数据更新</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> propFlag<span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token parameter">item<span class="token operator">:</span> any<span class="token punctuation">,</span> index<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item <span class="token operator">===</span> props<span class="token punctuation">.</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>propFlag<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initCharts</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-全局销毁器"><a href="#2-全局销毁器" class="headerlink" title="2.全局销毁器"></a>2.全局销毁器</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function-variable function">componentWillUnmount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-记一个操作符-可选链"><a href="#3-记一个操作符-可选链" class="headerlink" title="3.记一个操作符 ?? 可选链(?)"></a>3.记一个操作符 ?? 可选链(?)</h2><h3 id="3-1举个栗子"><a href="#3-1举个栗子" class="headerlink" title="3.1举个栗子 ??"></a>3.1举个栗子 ??</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&gt;</span> <span class="token keyword">undefined</span> <span class="token operator">??</span> <span class="token string">'default'</span><span class="token string">'default'</span><span class="token operator">&gt;</span> <span class="token keyword">null</span> <span class="token operator">??</span> <span class="token string">'default'</span><span class="token string">'default'</span><span class="token operator">&gt;</span> <span class="token boolean">false</span> <span class="token operator">??</span> <span class="token string">'default'</span><span class="token boolean">false</span><span class="token operator">&gt;</span> <span class="token string">''</span> <span class="token operator">??</span> <span class="token string">'default'</span><span class="token string">''</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">??</span> <span class="token string">'default'</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>so ~ : ?? 的意思是，如果 ?? 左边的值是 null 或者 undefined，那么就返回右边的值。</p><h3 id="3-1举个栗子-可选链"><a href="#3-1举个栗子-可选链" class="headerlink" title="3.1举个栗子 可选链(?)"></a>3.1举个栗子 可选链(?)</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>b <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Todo</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">?.</span>b<span class="token operator">?.</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Todo</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端,react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随记</title>
      <link href="/xiatian.github.io/2021/09/07/jiang-yi-jiang-wo-yu-dao-de-mian-shi-ti/"/>
      <url>/xiatian.github.io/2021/09/07/jiang-yi-jiang-wo-yu-dao-de-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试随记。</p></blockquote><h2 id="1-vue，react相关"><a href="#1-vue，react相关" class="headerlink" title="1.vue，react相关"></a>1.vue，react相关</h2><h3 id="1-1-vuex存储什么？vuex中的方法有哪些？"><a href="#1-1-vuex存储什么？vuex中的方法有哪些？" class="headerlink" title="1.1 vuex存储什么？vuex中的方法有哪些？"></a>1.1 vuex存储什么？vuex中的方法有哪些？</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">vuex是状态存储store下有    state：状态存储   getter：调用方法查询，可进行过滤   mutation：提交修改，改变state唯一方式   action：异步操作，执行完后需要 commit mutation 修改状态   module：分解成多个子模块，每个都是一个store，有自己的state、getter、action、mutation和module<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-原型链，有什么特点？"><a href="#1-2-原型链，有什么特点？" class="headerlink" title="1.2 原型链，有什么特点？"></a>1.2 原型链，有什么特点？</h3><pre class="line-numbers language-none"><code class="language-none">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是Object.prototype null <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-什么是-React-Hooks？"><a href="#1-3-什么是-React-Hooks？" class="headerlink" title="1.3 什么是 React Hooks？"></a>1.3 什么是 React Hooks？</h3><pre class="line-numbers language-none"><code class="language-none">Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-使用-React-Hooks-好处是啥？"><a href="#1-4-使用-React-Hooks-好处是啥？" class="headerlink" title="1.4 使用 React Hooks 好处是啥？"></a>1.4 使用 React Hooks 好处是啥？</h3><pre class="line-numbers language-none"><code class="language-none">首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-5-Vue-中-computed-和-watch-有什么区别"><a href="#1-5-Vue-中-computed-和-watch-有什么区别" class="headerlink" title="1.5 Vue 中 computed 和 watch 有什么区别"></a>1.5 Vue 中 computed 和 watch 有什么区别</h3><pre class="line-numbers language-none"><code class="language-none">1.计算属性 computed：（1）支持缓存，只有依赖数据发生变化时，才会重新进行计算函数；（2）计算属性内不支持异步操作；（3）计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属性)方法；（4）计算属性是自动监听依赖值的变化，从而动态返回内容。2.watch:(1) 不支持缓存，只要数据发生变化，就会执行侦听函数；(2) 侦听属性内支持异步操作；(3) 侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性；(3) 监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些其他事情。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-vue3-Proxy-里面的一些方法"><a href="#1-6-vue3-Proxy-里面的一些方法" class="headerlink" title="1.6 vue3 Proxy  里面的一些方法"></a>1.6 vue3 Proxy  里面的一些方法</h3><p><img src="https://z3.ax1x.com/2021/09/07/hozZaF.png" alt="proxy里面的一些方法"></p><h2 id="2-js-css相关"><a href="#2-js-css相关" class="headerlink" title="2.js css相关"></a>2.js css相关</h2><h3 id="2-1-类数组转数组"><a href="#2-1-类数组转数组" class="headerlink" title="2.1 类数组转数组"></a>2.1 类数组转数组</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span>、Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">2</span>、Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">3</span>、扩展运算符（…） <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-说说你对闭包的理解"><a href="#2-2-说说你对闭包的理解" class="headerlink" title="2.2 说说你对闭包的理解"></a>2.2 说说你对闭包的理解</h3><pre class="line-numbers language-none"><code class="language-none">使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在JavaScript中，函数即闭包，只有函数才会产生作用域。闭包有3个特性：（1）函数嵌套函数。（2）在函数内部可以引用外部的参数和变量。（3）参数和变量不会以垃圾回收机制回收。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-谈一谈你对this的理解，以及在各种环境下的this在浏览器里"><a href="#2-3-谈一谈你对this的理解，以及在各种环境下的this在浏览器里" class="headerlink" title="2.3 谈一谈你对this的理解，以及在各种环境下的this在浏览器里"></a>2.3 谈一谈你对this的理解，以及在各种环境下的this在浏览器里</h3><pre class="line-numbers language-none"><code class="language-none">在全局范围内this指向window对象在函数中，this永远指向最后调用他的那个对象(箭头函数除外)。在构造函数中，this指向new出来的新对象。call、apply、bind中的this被强绑定在指定的那个对象上。箭头函数this为父作用域的this，不是调用时的this。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-从输入-URL-到页面展示到底发生了什么？"><a href="#2-4-从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="2.4 从输入 URL 到页面展示到底发生了什么？"></a>2.4 从输入 URL 到页面展示到底发生了什么？</h3><pre class="line-numbers language-none"><code class="language-none">1、输入地址2、浏览器查找域名的 IP 地址3、浏览器向 web 服务器发送一个 HTTP 请求4、服务器的永久重定向响应6、服务器处理请求7、服务器返回一个 HTTP 响应8、浏览器显示 HTML9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-页面渲染html的过程"><a href="#2-5-页面渲染html的过程" class="headerlink" title="2.5 页面渲染html的过程"></a>2.5 页面渲染html的过程</h3><pre class="line-numbers language-none"><code class="language-none">1.解析HTML文件，创建DOM树（自上而下）2.解析CSS,形成CSS对象模型3.将CSS与DOM合并，构建渲染树4、布局与绘制，重绘与重排<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-重绘与重排"><a href="#2-6-重绘与重排" class="headerlink" title="2.6 重绘与重排"></a>2.6 重绘与重排</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。常见的引起重绘的属性：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th align="left">属性：</th><th align="center">–</th><th align="right">–</th><th align="right">–</th></tr></thead><tbody><tr><td align="left">color</td><td align="center">border-style</td><td align="right">visibility</td><td align="right">background</td></tr><tr><td align="left">text-decoration</td><td align="center">background-image</td><td align="right">background-position</td><td align="right">background-repeat</td></tr><tr><td align="left">outline-color</td><td align="center">outline</td><td align="right">outline-style</td><td align="right">border-radius</td></tr><tr><td align="left">outline-width</td><td align="center">box-shadow</td><td align="right">background-size</td><td align="right"></td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">重排也叫回流，简单的说就是重新生成布局，重新排列元素。下面情况会发生重排：    1.页面初始渲染，这是开销最大的一次重排    2.添加/删除可见的DOM元素    3.改变元素位置    4.改变元素尺寸，比如边距、填充、边框、宽度和高度等    5.改变元素内容，比如文字数量，图片大小等    6.改变元素字体大小    7.改变浏览器窗口尺寸，比如resize事件发生时    8.激活CSS伪类（例如：:hover）    9.设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow    10.查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-call和apply的区别"><a href="#2-7-call和apply的区别" class="headerlink" title="2.7 call和apply的区别"></a>2.7 call和apply的区别</h3><pre class="line-numbers language-none"><code class="language-none">call apply的作用都是改变this指向call：call() 方法和apply() 方法作用相同, 区别在于接收参数的方式不同, call() 需要列举所有传入的所有参数。apply：apply()方法需要将实参封装到一个数组中统一传递（即使只有实参只有一个，也要放到数组中）。严格来说只接收argument对象和数组两种形式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-8-new操作符具体干了什么呢"><a href="#2-8-new操作符具体干了什么呢" class="headerlink" title="2.8 new操作符具体干了什么呢?"></a>2.8 new操作符具体干了什么呢?</h3><pre class="line-numbers language-none"><code class="language-none">1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到 this 引用的对象中。3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-9-单向数据流和双向数据流"><a href="#2-9-单向数据流和双向数据流" class="headerlink" title="2.9 单向数据流和双向数据流"></a>2.9 单向数据流和双向数据流</h3><pre class="line-numbers language-none"><code class="language-none">单向数据流：所有状态的改变可记录、可跟踪，源头易追溯；所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性；一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data)；如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中双向数据流：无论数据改变，或是用户操作，都能带来互相的变动，自动更新。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-10-slice（）与splice（）的用法和区别"><a href="#2-10-slice（）与splice（）的用法和区别" class="headerlink" title="2.10 slice（）与splice（）的用法和区别"></a>2.10 slice（）与splice（）的用法和区别</h3><pre class="line-numbers language-mardown" data-language="mardown"><code class="language-mardown">1.slice(start，end)- 从start开始截取到end但是不包括end- 返回值为截取出来的元素的集合- 原始的数组不会发生变化2. splice(start,deleteCount,item1,item2…..);- start参数 开始的位置- deleteCount 要截取的个数- 后面的items为要添加的元素- 如果deleteCount为0，则表示不删除元素，从start位置开始添加后面的几个元素到原始的数组里面- 返回值为由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组- 这个方法会改变原始数组，数组的长度会发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-11-Event-Loop"><a href="#2-11-Event-Loop" class="headerlink" title="2.11  Event Loop"></a>2.11  Event Loop</h3><pre class="line-numbers language-none"><code class="language-none">1.浏览器的事件循环（event loop）中分成宏任务和微任务。JS 中任务分成同步任务和异步任务。2.JS 中主栈执行的大多数的任务，例如：定时器，事件绑定，ajax，回调函数，node中fs操作模块等就是宏任务3.promise, async/await, process.nextTick等就是微任务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端,面试,js,vue,react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号排版工具</title>
      <link href="/xiatian.github.io/2021/08/28/article-title/"/>
      <url>/xiatian.github.io/2021/08/28/article-title/</url>
      
        <content type="html"><![CDATA[<blockquote><p>微信公众号排版工具。问题或建议，请公众号留言。**<a href="#jump_8">程序员翻身</a>**</p></blockquote><p>写文章、发布文章<br>首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。</p><p>然后输入hexo new post “article title”，新建一篇文章。</p><p>然后打开D:\study\program\blog\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h2 id="1-Markdown-com-cn-简介"><a href="#1-Markdown-com-cn-简介" class="headerlink" title="1 Markdown.com.cn 简介"></a>1 Markdown.com.cn 简介</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cnpm init <span class="token operator">--</span>yescnpm i webpack<span class="token operator">-</span>cli <span class="token operator">--</span>save<span class="token operator">-</span>dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cnpm i webpack<span class="token operator">-</span>cli <span class="token operator">--</span>save<span class="token operator">-</span>dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cnpm install css<span class="token operator">-</span>loader <span class="token operator">--</span>save<span class="token operator">-</span>devcnpm install style<span class="token operator">-</span>loader <span class="token operator">--</span>save<span class="token operator">-</span>devcnpm install url<span class="token operator">-</span>loader <span class="token operator">--</span>save<span class="token operator">-</span>devcnpm install html<span class="token operator">-</span>webpack<span class="token operator">-</span>plugin <span class="token operator">--</span>save<span class="token operator">-</span>devcnpm install copy<span class="token operator">-</span>webpack<span class="token operator">-</span>plugin <span class="token operator">--</span>save<span class="token operator">-</span>dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>支持微信公众号、知乎和稀土掘金</li><li>点击右上方对应图标，一键复制到各平台</li></ul><h2 id="2-Markdown语法教程"><a href="#2-Markdown语法教程" class="headerlink" title="2 Markdown语法教程"></a>2 Markdown语法教程</h2><h3 id="2-1-标题站"><a href="#2-1-标题站" class="headerlink" title="2.1 标题站"></a>2.1 标题站</h3><p>不同数量的<code>#</code>可以完成不同的标题，如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>粗体、斜体、粗体和斜体，删除线，需要在文字前后加不同的标记符号。如下：</p><p><strong>这个是粗体</strong></p><p><em>这个是斜体</em></p><p><em><strong>这个是粗体加斜体</strong></em></p><p>~这里想用删除线~~</p><p>注：如果想给字体换颜色、字体或者居中显示，需要使用内嵌HTML来实现。</p><h3 id="2-3-无序列表"><a href="#2-3-无序列表" class="headerlink" title="2.3 无序列表"></a>2.3 无序列表</h3><p>无序列表的使用，在符号<code>-</code>后加空格使用。如下：</p><ul><li>无序列表 1</li><li>无序列表 2</li><li>无序列表 3</li></ul><p>如果要控制列表的层级，则需要在符号<code>-</code>前使用空格。如下：</p><ul><li>无序列表 1</li><li>无序列表 2<ul><li>无序列表 2.1</li><li>无序列表 2.2</li></ul></li></ul><p><strong>由于微信原因，最多支持到二级列表</strong>。</p><h3 id="2-4-有序列表"><a href="#2-4-有序列表" class="headerlink" title="2.4 有序列表"></a>2.4 有序列表</h3><p>有序列表的使用，在数字及符号<code>.</code>后加空格后输入内容，如下：</p><ol><li>有序列表 1</li><li>有序列表 2</li><li>有序列表 3</li></ol><h3 id="2-5-引用"><a href="#2-5-引用" class="headerlink" title="2.5 引用"></a>2.5 引用</h3><p>引用的格式是在符号<code>&gt;</code>后面书写文字。如下：</p><blockquote><p>读一本好书，就是在和高尚的人谈话。 ——歌德</p></blockquote><blockquote><p>雇用制度对工人不利，但工人根本无力摆脱这个制度。 ——阮一峰</p></blockquote><h3 id="2-7-链接"><a href="#2-7-链接" class="headerlink" title="2.7 链接"></a>2.7 链接</h3><p>微信公众号仅支持公众号文章链接，即域名为<code>https://mp.weixin.qq.com/</code>的合法链接。使用方法如下所示：</p><p>对于该论述，欢迎读者查阅之前发过的文章，<a href="https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA">你是《未来世界的幸存者》么？</a><br><a id="jump_8"></a></p><h3 id="2-8-图片"><a href="#2-8-图片" class="headerlink" title="2.8 图片"></a>2.8 图片</h3><p>插入图片，格式如下：</p><p><img src="https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg" alt="这里写图片描述"></p><p>支持 jpg、png、gif、svg 等图片格式，<strong>其中 svg 文件仅可在微信公众平台中使用</strong>，svg 文件示例如下：</p><p><img src="https://my-wechat.mdnice.com/mdnice/i_am_svg_20191024083453.svg"></p><p>支持图片<strong>拖拽和截图粘贴</strong>到编辑器中。</p><p>注：支持图片 <em><strong>拖拽和截图粘贴</strong></em> 到编辑器中，仅支持 https 的图片，图片粘贴到微信时会自动上传微信服务器。</p><h3 id="2-9-分割线"><a href="#2-9-分割线" class="headerlink" title="2.9 分割线"></a>2.9 分割线</h3><p>可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：</p><hr><h3 id="2-10-表格"><a href="#2-10-表格" class="headerlink" title="2.10 表格"></a>2.10 表格</h3><p>可以使用冒号来定义表格的对齐方式，如下：</p><table><thead><tr><th align="left">姓名</th><th align="center">年龄</th><th align="right">工作</th></tr></thead><tbody><tr><td align="left">小可爱</td><td align="center">18</td><td align="right">吃可爱多</td></tr><tr><td align="left">小小勇敢</td><td align="center">20</td><td align="right">爬棵勇敢树</td></tr><tr><td align="left">小小小机智</td><td align="center">22</td><td align="right">看一本机智书</td></tr></tbody></table><h2 id="3-特殊语法"><a href="#3-特殊语法" class="headerlink" title="3. 特殊语法"></a>3. 特殊语法</h2><h3 id="3-1-脚注"><a href="#3-1-脚注" class="headerlink" title="3.1 脚注"></a>3.1 脚注</h3><blockquote><p>支持平台：微信公众号、知乎。</p></blockquote><p>脚注与链接的区别如下所示：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">链接：<span class="token url">[<span class="token content">文字</span>](<span class="token url">链接</span>)</span>脚注：<span class="token url">[<span class="token content">文字</span>](<span class="token url">脚注解释</span> <span class="token string">"脚注名字"</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有人认为在<a href="https://en.wikipedia.org/wiki/Front-end_web_development" title="Front-end web development">大前端时代</a>的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。</p><p><a href="%E6%98%AF%E6%8C%87%E6%8E%8C%E6%8F%A1%E5%A4%9A%E7%A7%8D%E6%8A%80%E8%83%BD%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%88%A9%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%8A%80%E8%83%BD%E7%8B%AC%E7%AB%8B%E5%AE%8C%E6%88%90%E4%BA%A7%E5%93%81%E7%9A%84%E4%BA%BA%E3%80%82" title="什么是全栈工程师">全栈工程师</a>在业务开发流程中起到了至关重要的作用。</p><p>脚注内容请拉到最下面观看。</p><h3 id="3-2-代码块"><a href="#3-2-代码块" class="headerlink" title="3.2 代码块"></a>3.2 代码块</h3><blockquote><p>支持平台：微信代码主题仅支持微信公众号！其他主题无限制。</p></blockquote><p>如果在一个行内需要引用代码，只要用反引号引起来就好，如下：</p><p>Use the <code>printf()</code> function.</p><p>在需要高亮的代码块的前一行及后一行使用三个反引号，同时<strong>第一行反引号后面表示代码块所使用的语言</strong>，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// FileName: HelloWorld.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>  <span class="token comment">// Java 入口程序，程序从此入口</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 向控制台打印一条语句</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持以下语言种类：</p><pre class="line-numbers language-none"><code class="language-none">bashclojure，cpp，cs，cssdart，dockerfile, differlanggo，gradle，groovyhaskelljava，javascript，json，juliakotlinlisp，luamakefile，markdown，matlabobjectivecperl，php，pythonr，ruby，rustscala，shell，sql，swifttex，typescriptverilog，vhdlxmlyaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要更换代码高亮样式，可在上方<strong>代码主题</strong>中挑选。</p><p>其中<strong>微信代码主题与微信官方一致</strong>，有以下注意事项：</p><ul><li>带行号且不换行，代码大小与官方一致</li><li>需要在代码块处标志语言，否则无法高亮</li><li>粘贴到公众号后，用鼠标点代码块内外一次，完成高亮</li></ul><p>diff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> 新增项</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> 删除项</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致</strong></p><h3 id="3-3-数学公式"><a href="#3-3-数学公式" class="headerlink" title="3.3 数学公式"></a>3.3 数学公式</h3><blockquote><p>支持平台：微信公众号、知乎。</p></blockquote><p>行内公式使用方法，比如这个化学公式：$\ce{Hg^2+ -&gt;[I-] HgI2 -&gt;[I-] [Hg^{II}I4]^2-}$</p><p>块公式使用方法如下：</p><p>$$H(D_2) = -\left(\frac{2}{4}\log_2 \frac{2}{4} + \frac{2}{4}\log_2 \frac{2}{4}\right) = 1$$</p><p>矩阵：</p><p>$$<br>  \begin{pmatrix}<br>  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \<br>  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \<br>  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>  1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \<br>  \end{pmatrix}<br>$$</p><p>公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。</p><p>目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。</p><h3 id="3-4-TOC"><a href="#3-4-TOC" class="headerlink" title="3.4 TOC"></a>3.4 TOC</h3><blockquote><p>支持平台：微信公众号、知乎。</p></blockquote><p>TOC 全称为 Table of Content，列出全部标题。</p><p>[TOC]</p><p>由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。</p><h3 id="3-5-注音符号"><a href="#3-5-注音符号" class="headerlink" title="3.5 注音符号"></a>3.5 注音符号</h3><blockquote><p>支持平台：微信公众号。</p></blockquote><p>支持注音符号，用法如下：</p><p>Markdown Nice 这么好用，简直是{喜大普奔|hē hē hē hē}呀！</p><h3 id="3-6-横屏滑动幻灯片"><a href="#3-6-横屏滑动幻灯片" class="headerlink" title="3.6 横屏滑动幻灯片"></a>3.6 横屏滑动幻灯片</h3><blockquote><p>支持平台：微信公众号。</p></blockquote><p>通过<code>&lt;![](url),![](url)&gt;</code>这种语法设置横屏滑动滑动片，具体用法如下：</p><p><img src="https://z3.ax1x.com/2021/08/29/hGBbHH.png" alt="avatar"></p><h2 id="4-其他语法"><a href="#4-其他语法" class="headerlink" title="4 其他语法"></a>4 其他语法</h2><h3 id="4-1-HTML"><a href="#4-1-HTML" class="headerlink" title="4.1 HTML"></a>4.1 HTML</h3><p>支持原生 HTML 语法，请写内联样式，如下：</p><p><span style="display:block;text-align:right;color:orangered;">橙色居右</span><br><span style="display:block;text-align:center;color:orangered;">橙色居中</span></p><h3 id="4-2-UML"><a href="#4-2-UML" class="headerlink" title="4.2 UML"></a>4.2 UML</h3><p>不支持，推荐使用开源工具<code>https://draw.io/</code>制作后再导入图片</p><h2 id="5-致谢"><a href="#5-致谢" class="headerlink" title="5 致谢"></a>5 致谢</h2><ul><li>编程如画 <a href="https://github.com/mdnice/markdown-nice" title="插件原作者">markdown-nice-docs</a></li><li>歌词经理 <a href="https://github.com/lyricat/wechat-format" title="灵感来源">wechat-fromat</a></li><li>颜家大少 <a href="http://md.aclickall.com/" title="MdA2All">MD2All</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 更新说明,夏天 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
